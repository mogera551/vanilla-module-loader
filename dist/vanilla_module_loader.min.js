class e{static regist(e,t){}}class t{static toKebabCase=e=>"string"==typeof e?e.replaceAll(/_/g,"-").replaceAll(/([A-Z])/g,((e,t,i)=>(i>0?"-":"")+t.toLowerCase())):e}const i="kebab",a="snake",r="uppercamel",s="lowercamel";class o{static getNames(e){const o=t.toKebabCase(e),n=o.replaceAll("-","_"),l=o.split("-").map(((e,t)=>(void 0!==e[0]&&(e=e[0].toUpperCase()+e.slice(1)),e))).join(""),c=l.length>0?l[0].toLowerCase()+l.slice(1):l;return{[i]:o,[a]:n,[r]:l,[s]:c}}}const n=s;class l{defaultNameType=n;defaultPath="./";loadNames=[];prefixMap}const c=o.getNames("prefix-name"),p=o.getNames("sub-name");class f{static getPathInfo(e,t,n,l){const[f,h]=e.split("#");let g=f,m=h;const x=o.getNames(t),d=o.getNames(n);return g=g.replaceAll(`{${c[i]}}`,x[i]),g=g.replaceAll(`{${c[a]}}`,x[a]),g=g.replaceAll(`{${c[s]}}`,x[s]),g=g.replaceAll(`{${c[r]}}`,x[r]),g=g.replaceAll(`{${p[i]}}`,d[i]),g=g.replaceAll(`{${p[a]}}`,d[a]),g=g.replaceAll(`{${p[s]}}`,d[s]),g=g.replaceAll(`{${p[r]}}`,d[r]),f===g&&".js"!==g.slice(-3)&&(g=g+("/"!==e.slice(-1)?"/":"")+d[l]+".js"),m&&(m=m.replaceAll(`{${p[i]}}`,d[i]),m=m.replaceAll(`{${p[a]}}`,d[a]),m=m.replaceAll(`{${p[s]}}`,d[s]),m=m.replaceAll(`{${p[r]}}`,d[r])),{filePath:g,exportName:m}}}class h{prefix;path;get matchPrefix(){return`${this.prefix}-`}isMatch(e){return e.startsWith(this.matchPrefix)}getNames(e){const{prefix:t,path:i}=this;if(e.startsWith(this.matchPrefix)){return{prefixName:t,subName:e.slice(this.matchPrefix.length),path:i}}}}class g{#e;#t;#i;#a;#r;constructor(e){this.#a=e,this.#r=window.location,this.setConfig(new l)}setConfig(e){this.#t=Object.assign(new l,e),"prefixMap"in e&&void 0!==e.prefixMap&&this.setPrefixMap(e.prefixMap)}getConfig(){return this.#t}setPrefixMap(e){this.#i=new Map(Object.entries(e).map((([e,i])=>[e=t.toKebabCase(e),Object.assign(new h,{prefix:e,path:i})])))}getPrefixMap(){return this.#i}configFile(e){return this.#e=e,this}config(e){return this.setConfig(e),this}prefixMap(e){return this.setPrefixMap(e),this}get registrar(){return this.#a}async loadConfig(e){const t=this.#r.pathname.split("/");t[t.length-1]=e;const i=this.#r.origin+t.join("/");try{const e=await fetch(i),t=await e.json();return Object.assign(new l,t)}catch(e){throw new Error(e)}}async load(...e){if(void 0!==this.#e){const e=await this.loadConfig(this.#e);this.setConfig(e)}if(void 0===this.#i)throw new Error("prefixMap is not defined");if(void 0===this.#a)throw new Error("registrar is not defined");const i=Array.from(this.#i.values()),{defaultNameType:a,defaultPath:r}=this.#t;e=e.length>0?e:this.#t.loadNames;for(let s of e){let e;s=t.toKebabCase(s);const o=i.find((e=>e.isMatch(s)));if(void 0!==o){const t=o.getNames(s);e=f.getPathInfo(t.path,t.prefixName,t.subName,a)}if(void 0===e&&void 0!==r&&(e=f.getPathInfo(r,"",s,a)),void 0===e)throw new Error(`unmatch prefix and no defaultPath (loadName:${s})`);const n=this.#r.pathname.split("/");n[n.length-1]=e.filePath;const l=this.#r.origin+n.join("/");let c,p;try{c=await import(l)}catch(e){throw new Error(e)}if(void 0!==e.exportName){if(!(e.exportName in c))throw new Error(`${e.exportName} not found in module (exportName:${e.exportName}, ${e.filePath})`);p=c[e.exportName]}else p=c.default;this.#a.regist(s,p)}return this}static create(e){return new g(e)}}export{g as Loader,e as Registrar};
