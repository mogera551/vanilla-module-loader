class e{static register(e,t){}}class t{static toKebabCase=e=>"string"==typeof e?e.replaceAll(/[\._]/g,"-").replaceAll(/([A-Z])/g,((e,t,i)=>(i>0?"-":"")+t.toLowerCase())):e}const i="kebab",a="snake",r="uppercamel",s="lowercamel",o="dotted";class l{static getNames(e){const l=t.toKebabCase(e),n=l.replaceAll("-","_"),c=l.replaceAll("-","."),p=l.split("-").map(((e,t)=>(void 0!==e[0]&&(e=e[0].toUpperCase()+e.slice(1)),e))).join(""),f=p.length>0?p[0].toLowerCase()+p.slice(1):p;return{[i]:l,[a]:n,[r]:p,[s]:f,[o]:c}}}const n=s;class c{defaultNameType=n;defaultPath="./";loadNames=[];prefixMap}class p{prefix;path;get matchPrefix(){return`${this.prefix}-`}isMatch(e){return e.startsWith(this.matchPrefix)}getNames(e){const{prefix:t,path:i}=this;if(e.startsWith(this.matchPrefix)){return{prefixName:t,subName:e.slice(this.matchPrefix.length),path:i}}}}const f=l.getNames("prefix-name"),h=l.getNames("sub-name");class g{static getPathInfo(e,t,n,c){const[p,g]=e.split("#");let m=p,x=g;const d=l.getNames(t),u=l.getNames(n);return m=m.replaceAll(`{${f[i]}}`,d[i]),m=m.replaceAll(`{${f[a]}}`,d[a]),m=m.replaceAll(`{${f[s]}}`,d[s]),m=m.replaceAll(`{${f[r]}}`,d[r]),m=m.replaceAll(`{${f[o]}}`,d[o]),m=m.replaceAll(`{${h[i]}}`,u[i]),m=m.replaceAll(`{${h[a]}}`,u[a]),m=m.replaceAll(`{${h[s]}}`,u[s]),m=m.replaceAll(`{${h[r]}}`,u[r]),m=m.replaceAll(`{${h[o]}}`,u[o]),p===m&&".js"!==m.slice(-3)&&(m=m+("/"!==e.slice(-1)?"/":"")+u[c]+".js"),x&&(x=x.replaceAll(`{${h[i]}}`,u[i]),x=x.replaceAll(`{${h[a]}}`,u[a]),x=x.replaceAll(`{${h[s]}}`,u[s]),x=x.replaceAll(`{${h[r]}}`,u[r]),x=x.replaceAll(`{${h[o]}}`,u[o])),{filePath:m,exportName:x}}}class m{#e;#t;#i;#a;#r;constructor(e){this.#a=e,this.#r=window.location,this.setConfig(new c)}setConfig(e){this.#t=Object.assign(new c,e),"prefixMap"in e&&void 0!==e.prefixMap&&this.setPrefixMap(e.prefixMap)}getConfig(){return this.#t}setPrefixMap(e){this.#i=new Map(Object.entries(e).map((([e,i])=>[e=t.toKebabCase(e),Object.assign(new p,{prefix:e,path:i})])))}getPrefixMap(){return this.#i}configFile(e){return this.#e=e,this}config(e){return this.setConfig(e),this}prefixMap(e){return this.setPrefixMap(e),this}get registrar(){return this.#a}async loadConfig(e){const t=this.#r.pathname.split("/");t[t.length-1]=e;const i=this.#r.origin+t.join("/");try{const e=await fetch(i),t=await e.json();return Object.assign(new c,t)}catch(e){throw new Error(e)}}async load(...e){if(void 0!==this.#e){const e=await this.loadConfig(this.#e);this.setConfig(e)}if(void 0===this.#i)throw new Error("prefixMap is not defined");if(void 0===this.#a)throw new Error("registrar is not defined");const i=Array.from(this.#i.values()),{defaultNameType:a,defaultPath:r}=this.#t;e=e.length>0?e:this.#t.loadNames;for(let s of e){let e;s=t.toKebabCase(s);const o=i.find((e=>e.isMatch(s)));if(void 0!==o){const t=o.getNames(s);e=g.getPathInfo(t.path,t.prefixName,t.subName,a)}if(void 0===e&&void 0!==r&&(e=g.getPathInfo(r,"",s,a)),void 0===e)throw new Error(`unmatch prefix and no defaultPath (loadName:${s})`);const l=this.#r.pathname.split("/");l[l.length-1]=e.filePath;const n=this.#r.origin+l.join("/");let c,p;try{c=await import(n)}catch(e){throw new Error(e)}if(void 0!==e.exportName){if(!(e.exportName in c))throw new Error(`${e.exportName} not found in module (exportName:${e.exportName}, ${e.filePath})`);p=c[e.exportName]}else p=c.default;this.#a.register(s,p)}return this}static create(e){return new m(e)}}export{m as Loader,e as Registrar};
